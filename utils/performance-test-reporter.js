const base = require('@playwright/test/reporter');
const performanceReporter = require('./performance-reporter');
const fs = require('fs');
const path = require('path');

class PerformanceTestReporter {
    constructor() {
        this.allPerformanceData = [];
        this.testResults = {
            passed: 0,
            failed: 0,
            total: 0,
            duration: 0
        };
    }

    onBegin(config, suite) {
        this.startTime = Date.now();
        console.log('üé≠ Performance Test Reporter initialized');
    }

    onTestBegin(test) {
        test.startTime = Date.now();
    }

    onTestEnd(test, result) {
        const duration = Date.now() - test.startTime;
        
        // Update test results
        this.testResults.total++;
        if (result.status === 'passed') {
            this.testResults.passed++;
        } else {
            this.testResults.failed++;
            performanceReporter.addFailure(test.title, result.error?.message || 'Unknown error');
        }

        // Look for performance data in test attachments or stdout
        if (result.stdout && result.stdout.length > 0) {
            try {
                this.parsePerformanceOutput(result.stdout, test.title);
            } catch (error) {
                console.log(`Error parsing performance output for ${test.title}:`, error.message);
            }
        }
        
        // Process attachments for performance data
        if (result.attachments && result.attachments.length > 0) {
            result.attachments.forEach(attachment => {
                if (attachment.name && attachment.name.includes('performance')) {
                    try {
                        // If it's a JSON attachment with performance data
                        if (attachment.contentType === 'application/json' && attachment.body) {
                            const data = JSON.parse(attachment.body.toString());
                            this.processAttachmentData(data);
                        }
                    } catch (error) {
                        console.log(`Could not parse performance attachment: ${error.message}`);
                    }
                }
            });
        }
        
        // Check for performance metric files generated by individual tests
        this.collectPerformanceFiles();

        // Track slow tests as performance alerts
        if (duration > 30000) { // Tests taking more than 30 seconds
            performanceReporter.addAlert('Slow Test', `${test.title} took ${duration}ms to complete`);
        }

        // Add basic test timing as a critical operation
        const testCategory = this.categorizeTest(test.title);
        performanceReporter.addCriticalOperation(testCategory, duration);
        
        // Log detailed test performance for visibility
        if (duration > 10000) {
            console.log(`‚ö†Ô∏è Slow test detected: ${test.title} took ${duration}ms`);
        } else if (duration > 5000) {
            console.log(`üü° Moderate test duration: ${test.title} took ${duration}ms`);
        } else {
            console.log(`‚úÖ ${test.title} completed in ${duration}ms`);
        }
    }

    categorizeTest(testTitle) {
        if (testTitle.toLowerCase().includes('load') || testTitle.toLowerCase().includes('page')) {
            return 'Page Load';
        }
        if (testTitle.toLowerCase().includes('navigation') || testTitle.toLowerCase().includes('navigate')) {
            return 'Navigation';
        }
        if (testTitle.toLowerCase().includes('performance') || testTitle.toLowerCase().includes('monitor')) {
            return 'Performance Monitoring';
        }
        if (testTitle.toLowerCase().includes('alert') || testTitle.toLowerCase().includes('inbox')) {
            return 'Alert Operations';
        }
        if (testTitle.toLowerCase().includes('analysis')) {
            return 'Analysis Operations';
        }
        return 'General Operations';
    }

    parsePerformanceOutput(output, testTitle) {
        // Ensure output is a string and handle different types
        let outputStr = '';
        if (typeof output === 'string') {
            outputStr = output;
        } else if (Array.isArray(output)) {
            outputStr = output.join('\n');
        } else if (output && typeof output.toString === 'function') {
            outputStr = output.toString();
        } else {
            console.log(`Warning: Could not parse output for ${testTitle}, unexpected type:`, typeof output);
            return;
        }

        const lines = outputStr.split('\n');
        lines.forEach(line => {
            // Parse performance monitor output
            if (line.includes('Timer completed:')) {
                const match = line.match(/Timer completed: (\w+) = (\d+\.?\d*)ms/);
                if (match) {
                    const operation = match[1];
                    const duration = parseFloat(match[2]);
                    performanceReporter.addCriticalOperation(operation, duration);
                    console.log(`üìä Captured timer: ${operation} = ${duration}ms`);
                }
            }
            
            // Parse slow performance alerts
            if (line.includes('SLOW PERFORMANCE:')) {
                const match = line.match(/‚ö†Ô∏è\s*SLOW PERFORMANCE: (\w+) took (\d+)ms \(threshold: (\d+)ms\)/);
                if (match) {
                    const operation = match[1];
                    const duration = parseInt(match[2]);
                    const threshold = parseInt(match[3]);
                    performanceReporter.addCriticalOperation(operation, duration);
                    performanceReporter.addAlert('Performance Warning', `${operation} took ${duration}ms (threshold: ${threshold}ms)`);
                    console.log(`‚ö†Ô∏è Captured slow performance: ${operation} = ${duration}ms`);
                }
            }
            
            // Parse completed operations
            if (line.includes('completed in') && line.includes('‚úÖ')) {
                const match = line.match(/‚úÖ\s*(.+?)\s*completed in (\d+)ms/);
                if (match) {
                    const operation = match[1].trim();
                    const duration = parseInt(match[2]);
                    performanceReporter.addCriticalOperation(operation, duration);
                    console.log(`‚úÖ Captured operation: ${operation} = ${duration}ms`);
                }
            }
            
            // Parse page load times
            if (line.includes('page loaded in')) {
                const match = line.match(/(\w+) page loaded in (\d+)ms/);
                if (match) {
                    performanceReporter.addPageTime(match[1], parseInt(match[2]));
                }
            }
        });
    }

    collectPerformanceFiles() {
        // Check for individual performance metric files
        const metricsDir = path.join(process.cwd(), 'performance-metrics');
        if (fs.existsSync(metricsDir)) {
            const files = fs.readdirSync(metricsDir);
            files.forEach(file => {
                if (file.endsWith('.json')) {
                    try {
                        const filePath = path.join(metricsDir, file);
                        const data = JSON.parse(fs.readFileSync(filePath, 'utf8'));
                        this.processPerformanceMetrics(data);
                    } catch (error) {
                        console.log(`Could not parse performance file ${file}:`, error.message);
                    }
                }
            });
        }
    }

    processPerformanceMetrics(data) {
        // Process timers
        if (data.timers) {
            Object.entries(data.timers).forEach(([name, duration]) => {
                performanceReporter.addCriticalOperation(name, duration);
            });
        }
        
        // Process performance alerts
        if (data.alerts) {
            data.alerts.forEach(alert => {
                performanceReporter.addAlert('Performance Alert', alert.message || alert);
            });
        }
        
        // Process page load times if available
        if (data.pageLoadTimes) {
            Object.entries(data.pageLoadTimes).forEach(([page, time]) => {
                performanceReporter.addPageTime(page, time);
            });
        }
    }

    processAttachmentData(data) {
        // Process performance data from test attachments
        if (data.metrics) {
            Object.entries(data.metrics).forEach(([name, value]) => {
                performanceReporter.addCriticalOperation(name, value);
            });
        }
        
        if (data.pageLoadTimes) {
            Object.entries(data.pageLoadTimes).forEach(([page, time]) => {
                performanceReporter.addPageTime(page, time);
            });
        }
        
        if (data.alerts) {
            data.alerts.forEach(alert => {
                performanceReporter.addAlert('Test Attachment', alert);
            });
        }
    }

    onEnd(result) {
        this.testResults.duration = Date.now() - this.startTime;
        
        // Final collection of any remaining performance files
        this.collectPerformanceFiles();
        
        // Update the performance reporter with final results
        performanceReporter.updateTestResults({
            duration: this.testResults.duration,
            passed: this.testResults.passed,
            failed: this.testResults.failed,
            total: this.testResults.total
        });
        
        console.log(`üé≠ Performance Test Reporter: ${this.testResults.total} tests completed`);
        console.log(`   ‚úÖ Passed: ${this.testResults.passed}`);
        console.log(`   ‚ùå Failed: ${this.testResults.failed}`);
        console.log(`   ‚è±Ô∏è Duration: ${this.testResults.duration}ms`);
        
        // Don't save here - let the post-test script handle final report generation
    }
}

module.exports = PerformanceTestReporter;
